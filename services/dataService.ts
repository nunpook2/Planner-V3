import { firestore } from './firebase';
import { 
    Tester, CategorizedTask, DailySchedule, AssignedTask, 
    AssignedPrepareTask, TestMapping, LabReport, RawTask, TaskStatus 
} from '../types';

const getCollection = (name: string) => firestore.collection(name);

// --- TESTERS ---
export const getTesters = async (): Promise<Tester[]> => {
    const snapshot = await getCollection('analysts').get();
    return snapshot.docs.map((doc: any) => ({ id: doc.id, ...doc.data() } as Tester));
};

export const addTester = async (name: string): Promise<Tester> => {
    const docRef = await getCollection('analysts').add({ name });
    return { id: docRef.id, name };
};

export const deleteTester = async (id: string): Promise<void> => {
    await getCollection('analysts').doc(id).delete();
};

export const updateTester = async (id: string, data: Partial<Tester>): Promise<void> => {
    await getCollection('analysts').doc(id).update(data);
};

// --- CATEGORIZED TASKS ---
export const getCategorizedTasks = async (): Promise<CategorizedTask[]> => {
    const snapshot = await getCollection('categorizedTasks').get();
    return snapshot.docs.map((doc: any) => ({ docId: doc.id, ...doc.data() } as CategorizedTask));
};

export const addCategorizedTask = async (task: CategorizedTask): Promise<void> => {
    await getCollection('categorizedTasks').add(task);
};

export const updateCategorizedTask = async (docId: string, data: Partial<CategorizedTask>): Promise<void> => {
    await getCollection('categorizedTasks').doc(docId).update(data);
};

export const deleteCategorizedTask = async (docId: string): Promise<void> => {
    await getCollection('categorizedTasks').doc(docId).delete();
};

// --- SCHEDULE ---
export const getDailySchedule = async (date: string): Promise<DailySchedule | null> => {
    const doc = await getCollection('dailySchedules').doc(date).get();
    return doc.exists ? ({ id: doc.id, ...doc.data() } as DailySchedule) : null;
};

export const saveDailySchedule = async (date: string, schedule: Partial<DailySchedule>): Promise<void> => {
    await getCollection('dailySchedules').doc(date).set(schedule, { merge: true });
};

export const getExistingScheduleDates = async (): Promise<string[]> => {
    const snapshot = await getCollection('dailySchedules').get();
    return snapshot.docs.map((doc: any) => doc.id);
};

// --- ASSIGNED TASKS ---
export const addAssignedTask = async (task: AssignedTask): Promise<void> => {
    await getCollection('assignedTasks').add(task);
};

export const getAssignedTasks = async (): Promise<AssignedTask[]> => {
    const snapshot = await getCollection('assignedTasks').get();
    return snapshot.docs.map((doc: any) => ({ id: doc.id, ...doc.data() } as AssignedTask));
};

export const updateAssignedTask = async (id: string, data: Partial<AssignedTask>): Promise<void> => {
    await getCollection('assignedTasks').doc(id).update(data);
};

export const deleteAssignedTask = async (id: string): Promise<void> => {
    await getCollection('assignedTasks').doc(id).delete();
};

// --- PREPARE TASKS ---
export const assignItemsToPrepare = async (
    originalTask: CategorizedTask, 
    indices: number[], 
    assistant: Tester, 
    date: string, 
    shift: 'day' | 'night'
): Promise<void> => {
    const itemsToAssign = indices.map(i => originalTask.tasks[i]);
    const remainingItems = originalTask.tasks.filter((_, i) => !indices.includes(i));
    
    // Create AssignedPrepareTask
    const prepareTask: AssignedPrepareTask = {
        id: '', // Placeholder, generated by Firestore
        requestId: originalTask.id,
        tasks: itemsToAssign,
        category: originalTask.category,
        assistantId: assistant.id,
        assistantName: assistant.name,
        assignedDate: date,
        shift: shift,
        originalDocId: originalTask.docId!,
        originalIndices: indices
    };
    
    // 1. Add to prepareTasks collection
    await getCollection('prepareTasks').add(prepareTask);
    
    // 2. Update or delete original categorized task
    if (remainingItems.length > 0) {
        await updateCategorizedTask(originalTask.docId!, { tasks: remainingItems });
    } else {
        await deleteCategorizedTask(originalTask.docId!);
    }
};

export const getAssignedPrepareTasks = async (): Promise<AssignedPrepareTask[]> => {
    const snapshot = await getCollection('prepareTasks').get();
    return snapshot.docs.map((doc: any) => ({ id: doc.id, ...doc.data() } as AssignedPrepareTask));
};

export const markItemAsPrepared = async (prepTask: AssignedPrepareTask, itemIndex: number): Promise<void> => {
    const newTasks = [...prepTask.tasks];
    if (newTasks[itemIndex]) {
        newTasks[itemIndex].preparationStatus = 'Prepared';
        await getCollection('prepareTasks').doc(prepTask.id).update({ tasks: newTasks });
    }
};

// --- POOL MANAGEMENT ---
export const unassignTaskToPool = async (task: CategorizedTask): Promise<void> => {
    await addCategorizedTask(task);
};

export const returnTaskToPool = async (task: CategorizedTask): Promise<void> => {
    const taskWithStatus = {
        ...task,
        tasks: task.tasks.map(t => ({ 
            ...t, 
            isReturned: true, 
            returnReason: task.returnReason, 
            returnedBy: task.returnedBy 
        }))
    };
    await addCategorizedTask(taskWithStatus);
};

// --- MAPPINGS ---
export const getTestMappings = async (): Promise<TestMapping[]> => {
    const snapshot = await getCollection('testMappings').get();
    return snapshot.docs.map((doc: any) => ({ id: doc.id, ...doc.data() } as TestMapping));
};

export const addTestMapping = async (mapping: TestMapping): Promise<void> => {
    await getCollection('testMappings').add(mapping);
};

export const updateTestMapping = async (id: string, data: Partial<TestMapping>): Promise<void> => {
    await getCollection('testMappings').doc(id).update(data);
};

export const deleteTestMapping = async (id: string): Promise<void> => {
    await getCollection('testMappings').doc(id).delete();
};

// --- LAB REPORTS ---
export const saveLabReport = async (report: LabReport): Promise<void> => {
    // Sanitize to remove undefined fields which Firestore doesn't support
    const sanitize = (obj: any) => {
        const newObj: any = {};
        Object.keys(obj).forEach(key => {
            const val = obj[key];
            if (val !== undefined) {
                newObj[key] = val;
            }
        });
        return newObj;
    };

    const sanitizedReport = sanitize(report);

    if (report.id) {
        const { id, ...data } = sanitizedReport;
        await getCollection('labReports').doc(id).update(data);
    } else {
        await getCollection('labReports').add(sanitizedReport);
    }
};

export const getLabReport = async (date: string, shift: 'day' | 'night'): Promise<LabReport | null> => {
    const snapshot = await getCollection('labReports')
        .where('date', '==', date)
        .where('shift', '==', shift)
        .get();
        
    if (!snapshot.empty) {
        const reports = snapshot.docs.map((doc: any) => ({ id: doc.id, ...doc.data() } as LabReport));
        reports.sort((a: LabReport, b: LabReport) => b.timestamp - a.timestamp);
        return reports[0];
    }
    return null;
};

// --- CLEANUP ---
export const runCleanup = async (): Promise<{ deleted: number }> => {
    const snapshot = await getCollection('categorizedTasks').get();
    let deleted = 0;
    const batch = firestore.batch();
    
    snapshot.docs.forEach((doc: any) => {
        const data = doc.data();
        if (!data.tasks || data.tasks.length === 0) {
            batch.delete(doc.ref);
            deleted++;
        }
    });
    
    await batch.commit();
    return { deleted };
};

export const clearAllTaskData = async (): Promise<void> => {
    const collections = ['categorizedTasks', 'assignedTasks', 'prepareTasks', 'dailySchedules', 'labReports'];
    for (const col of collections) {
        const snapshot = await getCollection(col).get();
        if (snapshot.size === 0) continue;
        
        const batch = firestore.batch();
        snapshot.docs.forEach((doc: any) => batch.delete(doc.ref));
        await batch.commit();
    }
};